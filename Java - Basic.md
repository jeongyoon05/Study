# Java - Basic 

- 자바는 1991년 제임스 고슬링을 비롯한 선 마이크로시스템스 연구원들이 처음 개발했다.

- 가전제품이나 휴대용 장치등에 사용하는 소프트웨어를 만들기 위해 독립적으로 작동하는 더 안정된 프로그래밍 언어가 필요하여 자바가 만들어졌다.

  

### 플랫폼에 종속되지 않는다.

- 자바에서는 .exe의 실행 파일 대신 .class의 확장자를 가진 바이트 코드를 생성
- 생성된 바이트 코드를 `자바 가상 머신`에서 실행하여, 각 운영체제에 맞는 실행 파일 생성
- 이러한 특성은 초반에 프로그램의 실행 속도를 저하시킨 원인이 되었지만, 자바 컴파일러가 JIT 컴파일 방식으로 개선되며 실행 속도가 개선됨

참고) JIT(Just In Time) 컴파일러는 실행 시점에 기계어 코드 생성, 같은 코드 반복일 경우 이전에 만든 기계어 재사용의 특징이 있다.



### 객체 지향 언어

- 객체 지향 프로그래밍이란 일의 순서가 아닌 여러 객체의 협력(상호 관계)을 통해 프로그램을 구현하는 것
- 공통으로 사용하는 부분을 수정하지 않고도 새 기능 쉽게 추가 가능
- 유지보수가 쉽고 확장성이 좋은 프로그램이 될 수 있음

### 안정적인 프로그램

- 자바는 포인터 문법을 제공하지 않아 메모리를 직접 제어하지 않음. 그에 따라 오류 위험성을 줄임
- Garbage Collector를 이용해 동적 메모리를 수거하므로 효율적인 메모리 관리가 가능함

### 오픈소스

- JDK(Java Development Kit)를 가지고 있어 프로그램을 빠르게 개발할 수 있음
- 자바를 활용한 오픈 소스가 많이 개발되어 있기 때문에 그 소스들을 연동하여 더 풍부한 기능을 빠르게 구현할 수 있음

참고) JDK는 클래스, 자료구조, 네트워크, 입출력, 예외처리 등에 최적화된 알고리즘 라이브러리를 제공

---

### 원시자료형(Primitive type)

![img](https://dinfree.com/lecture/language/img/java1.png)

각 자료형의 명칭과 크기등은 다음과 같다.

| 자료형  | 크기                                                | 설명                                                         |
| ------- | --------------------------------------------------- | ------------------------------------------------------------ |
| byte    | 1바이트, -128~127                                   | 가장 작은 단위로 8bit로 구성된 1byte를 기본으로 함.          |
| char    | 2바이트, 0~65535                                    | 음수를 포함하지 않는 unsigned 자료형으로 문자 표현에 적합.   |
| short   | 2바이트, -32768~32767                               | 음수를 포함한 2바이트 크기의 자료형. 작은 데이터 처리에 적합. |
| int     | 4바이트, -2147483648~2147483647                     | 정수의 기본 자료형이지만 충분한 크기가 아님에 주의           |
| long    | 8바이트, -9223372036854775808 ~ 9223372036854775807 | 충분한 숫자값이 필요한 경우 사용                             |
| float   | 4바이트, 1.4E-45 ~ 3.4028235E38                     | 실수형의 기본형이 아니므로 숫자뒤에 `f`를 붙여 사용          |
| double  | 8바이트,  4.9E-324 ~ 1.7976931348623157E308         | 실수형의 기본 자료형                                         |
| boolean | 1바이트, true 혹은 false                            | 논리형으로 참, 거짓을 표현                                   |

- 자바에서는 유니코드를 기본으로 지원하기 때문에 문자 처리에 2바이트가 필요.
- 문자 출력은 유니코드 번호에 등록된 문자가 출력되므로 실제 `char`에 저장되는 값은 유니코드 번호로 숫자값임.
- JVM에서 피연산자를 4바이트 단위로 처리하기 때문에 int 보다 작은 자료형의 값을 연산하는 경우 자동으로 `int` 로 변환되어 처리됨.
- `float` 형을 지정하기 위해서는 실수값 뒤에 `F/f`를 붙여줘야 함.
- 정수값을 `long` 형으로 처리하기 위해서는 뒤에 `L/l`을 붙여줘야 함.
- 문자열은 원시자료형이 아닌 클래스 타입.

변수 사용 ex )

```java
int num1; 	// 정수형 변수
char c1 = 'A'	 // 문자형 변수를 선언하고 'A'로 초기화
long num2 = 212355L; 	// long 정수형 변수를 선언
float num3 = 13.4F; 	// float 실수형 변수를 선언
boolean result = true 	// 논리형 변수를 선언하고 true로 초기화 
```



### 자바 변수 유형

프로그램 코드 내에서 변수의 위치에 따라 몇 가지 유형으로 변수를 구분할 수 있습니다.



`멤버변수(Member variable)`

- 클래스 내부에 선언된 변수들로 객체의 속성에 해당
- 인스턴스 변수와 클래스 변수로 구분됨

`인스턴스 변수(Instance variable)`

- 클래스가 인스턴스 될 때 초기화되는 변수
- 인스턴스를 통해서만 접근할 수 있음

`매개 변수(Parameter)`

- 메서드에 인자로 전달되는 값을 받기 위한 변수
- 메서드 내에서는 지역변수 처럼 사용됨

`클래스 변수(Class variable)`

- static 으로 선언된 변수
- 인스턴스 생성없이 클래스 이름.변수명으로 사용 가능
- main() 메서드에서 참조 가능

변수 ex )

```java
public class Variables {
	// 멤버 변수, 인스턴스 변수
	int num1;
	
	// 멤버 변수, 클래스 변수
	static int num2;
	
	// 매개 변수
	public void printName(String name) {
		// 지역 변수
		String prtMsg = name + "Hello";
		System.out.println(prtMsg);
	}
	
	public static void main(String[] args) {
		// 인스턴스 생성
		Variables mc = new Variables();
		// 인스턴스 변수 사용
		mc.num1 = 100;
		// 클래스 변수 사용
		Variables.num2 = 50;	// num2 = 50 으로 사용해도 됨
		
		// 인자로 매개 변수에 값 전달
		mc.printName("홍길동");
		
		System.out.printf("%d, %d", mc.num1, Variables.num2);
		
	}
}
```

#### 실행 결과

```java
홍길동 Hello
100, 50
```



### 메서드

메서드는 특정 객체의 동작이나 행위를 정의한 것으로 클래스의 주요 구성요소 입니다.

`선언 방법`

```java
[접근제어자] 리턴타입 메서드명([인자..]) {

}
```

- 접근제어자 : 메서드의 접근 범위를 지정
- 리턴 타입을 반드시 명시해야 하며 리턴이 없는 경우에도 `void`를 사용

`메서드 오버로딩(Overloading) `

- 리턴값이나 인자가 다른 여러 메서드를 동일한 이름으로 선언하는것

`가변 인자(Variable arguments)`

- 인자의 수가 유동적인 메서드
- `String... msg`와 같이 가변인자를 사용

`생성자 메서드(Constructor method)`

- 클래스가 인스턴스될 때 호출되는 메서드
- 클래스가 실행시 초기화 작업을 수행
- 메서드 오버로딩에 의해 여러 생성자가 있을 수 있음

메서드 ex )

```java

public class Methods {
    String name;

    // 생성자 메서드
    Methods() {
        name = "홍길동";
        System.out.printf("#생성자: %s\n",name);
    }

    // 인자가 없는 메서드
    void printName() {
        System.out.printf("#printName(): %s\n",name);
    }

    // 인자가 하나인 메서드(메서드 오버로딩), 인자 값이 출력됨
    void printName(String name) {
        System.out.printf("#printName(String name): %s\n", name);
    }

    // 가변인자를 사용한 메서드
    void printNames(String...name) {
    	System.out.println("#printNames(String...name)");
        for(String s : name) {
            System.out.println(s);
        }
    }

    // 인자가 두개인 메서드
    int calc(int num1, int num2){
        return num1+num2;
    }
    
    public static void main(String[] args) {
    	Methods m = new Methods();
    	m.printName();
    	m.printName("김길동");
    	m.printNames("아무개","홍길동","김사랑");
    	System.out.printf("#calc(int num1, int num2): %d ", m.calc(20,50));
    }
}
```

- 생성자 메서드는 객체가 생성될때 자동으로 호출됨
- 동일한 이름의 메서드는 인자에 따라 해당 메서드가 호출됨
- 가변인자를 통해 그때 그때 필요한 인자를 전달 가능
- 리턴이 있는 메서드는 리턴 값을 받아 사용

#### 실행결과

```java
#생성자: 홍길동
#printName(): 홍길동
#printName(String name): 김길동
#printNames(String...name)
아무개
홍길동
김사랑
#calc(int num1, int num2): 70 
```



### 자바 메모리 관리

`JVM`은 시스템(OS)으로 부터 프로그램을 실행하는데 필요한 메모리를 할당 받고 JVM은 할당 받은 메모리를 용도에 따라 세 영역으로 나누어 관리 한다.



자바는 C언어와 같이 직접적인 메모리 주소에 접근할 수 없으며 개발자가 메모리를 할당 받거나 반환하지 않아도 되는 구조이기 때문에 일반적인 응용 프로그래머의 경우 구체적인 메모리 관리에 대해서는 자세히 알 필요는 없다.

다만 프로그램의 동작 구조를 보다 정확하게 이해하기 위해서는 다음에 나오는 내용을 알아둘 필요가 있다.



`메서드 영역(method area)`

프로그램 실행 중 특정 클래스가 사용되면, JVM은 해당 클래스의 클래스 파일(*.class)을 읽어서 분석한 다음 클래스에 대한 정보를 이곳에 저장하게 된다. 이때 `클래스변수`나 `메서드(static)`도 이 영역에 함께 생성됩니다.



`main()`에서 클래스에 선언된 변수에 접근할 수 없는 것도 이러한 이유로 `main()`은 `static`으로 선언 되어 있기 때문에 클래스에 선언된 멤버변수(인스턴스 변수)를 사용할 수 없으며 인스턴스의 변수들은 힙 영역에 생성되기 때문에 인스턴스를 통해서만 접근이 가능한 것이다.

`힙 영역(heap area)`

프로그램 실행 중 생성되는 `인스턴스`는 모두 이곳에 생성 됩니다. 즉, 인스턴스 변수들이 생성되는 공간으로 대부분의 메모리 공간은 힙 영역이 된다.



서버 시스템이나 메모리 사용이 많은 프로그램을 개발하거나 실행할때 힙 메모리 부족으로 문제가 발생할 수 있으며 이 경우`JVM메모리 옵션`을 조정해 줘야 한다.

`호출 스택(call stack or execution stack)`

호출 스택은 `메서드 실행`에 필요한 메모리 공간을 말한다. 메서드가 호출될때 호출스택에는 호출된 메서드를 위한 메모리가 할당되며 이 메모리는 메서드가 작업을 수행하는 동안 `지역변수 및 매개변수`들의 연산 중간결과 등을 저장하는데 사용한다. 메서드가 작업을 마치면 할당 되었던 메모리 공간은 반환되어 정리된다.

지역변수들의 경우 멤버변수나 다른 함수에서 사용된 변수들과 이름이 같아도 문제가 없는 이유 이다.



`가비지 컬렉션 (garbage collection)`

줄여서 `GC`라고도 한다. 쉽게 설명해서 자바에서 사용되지 않는 메모리를 정리해주는 작업이다. GC과정은 전체적인 `JVM의 성능에 영향`을 미치는 요소이기 때문에 오랜시간 동안 발전을 거듭해 오늘에 이르케 되었습니다. 가비지 컬렉터(gabage collector)는 가비지 컬렉션을 수행하는 주체가 된다.

규모가 크지 않거나 특히 `컨테이너 기반`에서 동작하는 (웹서버(WAS) 프로그램이나 안드로이드 등) 프로그램들의 경우 일반 개발자들이 신경쓸 일이 많지 않고 개발자가 직접 `System.gc()`를 이용해 가비지 컬렉션을 동작시키는 것은 권장되지 않음![img](https://dinfree.com/lecture/language/img/java2.png)

`New/Young 영역`

- Eden : 객체들이 최초로 생성되는 공간
- Survivor 0/1 : Eden에서 참조되는 객체들이 저장되는 공간

`Old 영역`

- New area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간 Eden영역에 객체가 가득차게 되면 첫번째 GC(minor GC)가 발생한다.
- Eden영역에 있는 값들은 Survivor 1영역에 복사되고 이 영역을 제외한 나머지 영역의 객체들은 삭제된다.

`Permanent Generation`

- 생성된 객체들의 정보의 주소값이 저장된 공간
- Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역
- JVM에 의해서 실행됨

프로그램에서 GC대상이 되는것은 다음과 같다.

- 모든 객체 참조가 null인 경우
- 객체가 블럭 안에서 생성되고 블럭이 종료된 경우
- 부모 객체가 null이 된 경우, 자식 객체는 자동적으로 GC대상
- 객체가 Weak 참조만 가지고 있을 경우
- 객체가 Soft 참조이지만 메모리 부족이 발생한 경우

`자바 객체 참조`

> 좀 더 메모리를 고려하는 프로그램을 개발해야 하는 경우는 단순히 `new` 가 아니라
>
> `WeakReference` 혹은 `SoftReference` 를 이용해 객체를 생성해야 적절한 메모리 관리가 이루어 진다.

`Strong Reference`

- 일반적으로 new를 통해서 객체를 생성할때 발생하는 참조 유형
- 가비지 컬렌션의 대상 제외

`Soft Reference`

- 강한 참조와는 다르게 GC에 의해 수거될수 있고, 수거되지 않을 수도 있다.
- 메모리에 충분한 여유가 있다면 GC에 의해 수거되지 않음
- out of memory의 시점에 가깝다면 수거될 확률이 높다.

`Weak Reference`

- 약한 참조는 GC가 발생하면 무조건 수거됨
- WeakReference가 사라지는 시점이 GC의 실행 주기와 일치하며 이를 이용하여 짧은 주기에 자주 사용되는 객체를 캐시할 때 유용
